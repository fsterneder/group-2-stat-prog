---
title: "Project PolyR"
subtitle: "Programming in Statistics - Project"
author: "Vilsmeier Johannes, Sterneder Florian, Schaub Andrea"
date: '`r Sys.Date()`'
output:
  html_document:
    code_folding: show
    css: ../rstyle.css
    theme: cosmo
    highlight: tango
    number_sections: true
    toc: true
    toc_float: yes
    fig_width: 7
    fig_height: 4.5
subtitle: Programming in Statistics - Project
---

```{r setup, include=FALSE}
library(knitr)
library(tidyverse)
opts_chunk$set(echo = TRUE,
               collapse = FALSE,
               comment = "",
               strip.white = TRUE,
               warning = FALSE,
               messages = FALSE,
               out.width = "70%",
               fig.align = "center")
theme_set(theme_light())
```

# Explanations and drawings {.tabset .tabset-fade .tabset-pills}

> Explain what every function does.  Importantly,  you need to include the environment in which the function is bound and the other variables in this environment.  Alternatively,  you  could  draw  a  picture  of  all  of  the  environments  which  enclose  functions which are bound in the expert list.  Both capture the same information (though the picture is more succinct)

## makeBidderGeom

This function constructs a list containing four functions. One of the functions (state) stores a list with the current state. We have a bidAccepted function which increments the wealth value in the state, the bidRejected which decreases the wealth value and the bid function which implements the geometric behavior of the bid.

```{r eval=F}
makeBidderGeom = function(wealth=.05, frac = .5) {
  list( 
    state = function() { 
      list(
        wealth = wealth,
        frac   = frac
      ) 
    },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth > .0001, wealth*frac, wealth) }
  )
}
```

## makeBidderConst

See makeBidderGeom, almost the same besides the bid function which has a different (constant) bidding behavior and the state.

```{r eval=F}
makeBidderConst = function(wealth=.05, const=.01) {
  list( 
    state = function() { 
      list(
        wealth  = wealth,
        const   = const
      ) 
    },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth >= const, const, wealth) }  
  )
}
```

## makeRawSource

This constructor handles the positions 

```{r eval=F}
makeRawSource <- function(ncolumns) {
  activeColumns  = 0:ncolumns
  position       = ncolumns
  prevPosition   = NA
  nactive        = ncolumns
  
  list(
    name = "Marginal",
    state = function() { 
      list(
        position     = position, 
        prevPosition = prevPosition,
        active       = activeColumns,
        nactive      = sum(!is.na(activeColumns[-1]))
      )
    },
    generateFeature = function() { 
      prevPosition  <<- position
      position      <<- max(activeColumns[activeColumns < position], na.rm=T)
      return(prevPosition) 
    },
    dropLastFeature = function() { activeColumns[prevPosition+1] <<- NA },
    udPass = function() {
      position <<- max(activeColumns, na.rm=T)
      prevPosition <<- NA
    }
  )
}
```

## makeExpert

```{r eval=F}
makeExpert <- function (bidder, constructor) {
  list(
    name         = "Geom",
    bidder       = bidder,
    constructor  = constructor,
    state        = function() { 
      list(
        wealth   = bidder$state()$wealth,
        position = constructor$state()$position
      )
    },
    bid          = function() { bidder$bid() },
    feature      = function() { constructor$generateFeature() },
    finishedPass = function() { constructor$state()$position == 0 },
    finished     = function() { constructor$state()$nactive == 0 },
    passTest     = function(a) {
      bidder$bidAccepted(a)
      constructor$dropLastFeature() 
    },
    pay          = function(payment) {
      bidder$bidRejected(payment)
    },
    udPass       = function() { constructor$udPass() }
  )
}
```

## makeExpertGeom

```{r eval=F}
makeExpertGeom <- function(ncolumns, wealth=.05, frac=.5) {
  makeExpert(
    makeBidderGeom(wealth, frac),
    makeRawSource(ncolumns)
  )
}
```

## environmentDrawing

# Comment the code

> Comment the code thoroughly. After part 1, you should understand how the code works.  Now comment it to help explain it to others.  Essentially every line should be commented. Remember, you aren’t explaining what the code does,  eg,  for line 42,  “ifelse checks the condition, bids wealth*frac if it holds, otherwise wealth.” Instead, explain why things are done as they are, eg, “ifelse statement ensures termination by eventually bidding remaining wealth”. Note that some things are worth explaining a bit of the how. For example, line 95, “+1 accounts for the zero at the beginning of the activeColumns vector”.

```{r results="hide"}
makeBidderGeom = function(wealth=.05, frac = .5) {
#input of function has default values. If wealth and/or frac are not given, these values are used. 
#list contains: list with state (saving input wealth, and frac as a list)
#and 3 functions 
  list( 
    state = function() { 
      list(
        wealth = wealth,
        frac   = frac
      ) 
    },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth > .0001, wealth*frac, wealth) }
  )
}

makeBidderConst = function(wealth=.05, const=.01) {
#this function has again default values. It is the same as the one before, only the bid-function differs. 
  list( 
    state = function() { 
      list(
        wealth  = wealth,
        const   = const
      ) 
    },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth >= const, const, wealth) }  
  )
}

makeRawSource <- function(ncolumns) {
#this function has one input variable, the number of columns.
#It creates 4 variables and a list (containing the variable name and 4 functions, see comments there)

#every column is stored as an active column (WHY DOES IT START WITH 0?)
  activeColumns  = 0:ncolumns
  position       = ncolumns
  prevPosition   = NA
  nactive        = ncolumns
  
  list(
    name = "Marginal",
    #first function:
    state = function() {
      list(
      #the list stores the variables like before, except the nactive changes.
      #the importance of this list and function creating it will be explained in "Why a list?"
        position     = position, 
        prevPosition = prevPosition,
        active       = activeColumns,
        #the first active column is dropped, then the sum (checking for NAs before) is computed
        nactive      = sum(!is.na(activeColumns[-1]))
      )
    },
    #second function:
    generateFeature = function() {
    #here the positions are changed. With <<- we change the prevPosition and position variable in the parent environment
      prevPosition  <<- position
      position      <<- max(activeColumns[activeColumns < position], na.rm=T)
      return(prevPosition) 
    },
    #third function:
    dropLastFeature = function() { 
    #this adds another column at the end, making it NA? (if generateFeature is done before)
      activeColumns[prevPosition+1] <<- NA 
      },
    #fourth function:
    udPass = function() {
    #new position is the last column (with highest (index) number)
      position <<- max(activeColumns, na.rm=T)
      #prevPosition gets NA, to avoid errors if you forget to change it when doing a new round?
      prevPosition <<- NA
    }
  )
}

makeExpert <- function (bidder, constructor) {
#this function takes two variables, a bidder and a constructor. They have to be given. 
#it creates a list, containing the name ("Geom"), the bidder, constructor and 8 functions. 
  list(
    name         = "Geom",
    bidder       = bidder,
    constructor  = constructor,
    #Function 1:
    state        = function() { 
      list(
        wealth   = bidder$state()$wealth,
        position = constructor$state()$position
      )
    },
    #Function 2:
    bid          = function() { bidder$bid() },
    #Function 3:
    feature      = function() { constructor$generateFeature() },
    #Function 4:
    finishedPass = function() { constructor$state()$position == 0 },
    #Function 5:
    finished     = function() { constructor$state()$nactive == 0 },
    #Function 6:
    passTest     = function(a) {
      bidder$bidAccepted(a)
      constructor$dropLastFeature() 
    },
    #Function 7:
    pay          = function(payment) {
      bidder$bidRejected(payment)
    },
    #Function 8:
    udPass       = function() { constructor$udPass() }
  )
}

makeExpertGeom <- function(ncolumns, wealth=.05, frac=.5) {
#this function takes the number of columns, and optional the wealth and frac. 
#it calls the makeExpert function above, with 
  makeExpert(
  #bidder being the bidder made by the makeBidderGeom function. 
  #The input values for wealth and frac are passed
    makeBidderGeom(wealth, frac),
  #constructor is made by the makeRawSource function. 
  #The input value of ncolumns is passed on. 
    makeRawSource(ncolumns)
  )
}

seed = 421232
set.seed(seed) 
nNull = 20; nNonNull = 20
nulls = runif(nNull)
nonNulls = runif(nNonNull, 0, .05)
pvals = sample(c(nulls, nonNulls)) 

omega = .1
expert = makeExpertGeom(length(pvals), wealth=omega, frac=.1)
rejectedHyp = list()
pass = 1

while (!expert$finished() && expert$state()$wealth > 0) {
  index = expert$feature()
  bid = expert$bidder$bid()
  expert$pay(bid)
  if (pvals[index] < bid) {
    expert$passTest(omega)
    rejectedHyp[[1+length(rejectedHyp)]] = index
  }
  if(expert$finishedPass()) {
    expert$udPass()
    pass = pass+1
  }
}
rejectedHyp; pass
pvals[unlist(rejectedHyp)]
```

# Why a list?

> The state function returns the values of the private variables.  Why is this a function that returns a list and not just a list of the values of the private variables?

If it would be a list the values wouldn't update and would only return the values at the initialization of the parent function. Let's take our bidder function and see how that works practice.

```{r}
makeBidderGeomNoFun = function(wealth=.05, frac = .5) {
  list( 
    state = list(
      wealth = wealth,
      frac   = frac
    ), 
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth > .0001, wealth*frac, wealth) }
  )
}
```
Again, the only difference to our old bidder function is that the state is now a list instead of a function. 

```{r}
setn = 5
testA <- makeBidderGeom()
testB <- makeBidderGeomNoFun()

state <- 
  function() {
    list(
      hasFunction = testA$state()$wealth,
      hasList = testB$state$wealth
    )
  }

state()
```
As we can see we have the same starting values. Now let's take a loop which calls the `bidAccept` function and see what happens to the `state`.

```{r}
while(setn >= 0){
  testA$bidAccepted(100) 
  testB$bidAccepted(100) 
  setn = setn-1
}

state()
```

We find that bidderFunction with a list as a state doesn't update and therefore would be unusable in a program.

# Multiple experts {.tabset .tabset-fade .tabset-pills}

> Generalize the code to use multiple experts (store the experts in a list).  While the code should be general, test it using two experts; one expert should use a geometric bidder and the other should use the constant bidder. Start each expert with wealth = omega/2.  The expert with the maximum bid “wins”, and gets to perform its test.  Note that each expert has private bidder and constructor objects (why?).  Only use one makeExpert function (you should pass it an argument for which bidder function to use).

## Code

```{r}
makeMultiExpert <- function(..., ncolumns, wealth=.05) {
  output <- list()
  for (i in seq_along(list(...))) {
    output[[i]] <- makeExpert(
      list(...)[[i]](wealth),
      makeRawSource(ncolumns)
    )
  }
  output
}
```

To keep the code as simple and as general as possible we opted to use partial function application in regard to the bidder options problem. The other option would be to check which function was supplied and then apply the right option but this would require hardcoding every single bidder and bidder option and wouldn't be general in our opinion.

There are many functional packages that provide partial function application but we went with purrr since we used the tidyverse in our class.

## Example

```{r}
seed = 421232
set.seed(seed) 
nNull = 20; nNonNull = 20
nulls = runif(nNull)
nonNulls = runif(nNonNull, 0, .05)
pvals = sample(c(nulls, nonNulls)) 
omega = .1

expertConst = partial(makeBidderConst, const=.1)
expertGeom  = partial(makeBidderGeom,  frac=.1)
expert = makeMultiExpert(expertConst, expertGeom, ncolumns=length(pvals), wealth=omega/2)
names(expert) <- c("const","geom")
expert$const$name = "Const"

for(i in seq_along(expert)){
  expert[[i]]$rejectedHyp <- list()
  expert[[i]]$pass <- 1
}

while (!reduce(map(expert, function(x) x$finished()), function(x,y) x || y) && reduce(map(expert, function(x) x$state()$wealth > 0), function(x,y) x || y)) {
  bid = list(const = expert$const$bidder$bid(), geom = expert$geom$bidder$bid())

  ifelse(bid$const > bid$geom, wstr <- "const", wstr <- "geom")

  winner <- expert[[wstr]]
  index = winner$feature()
  maxBid <- max(unlist(bid))

  #print(paste("index: ", index, "wealth const: ", expert$const$state()$wealth, "wealth geom: ", expert$geom$state()$wealth, "bid: ", maxBid, "p: ", pvals[min(unlist(index))]))

  winner$pay(maxBid)

  if (pvals[index] < maxBid) {
    winner$passTest(omega)
    winner$rejectedHyp[[1+length(winner$rejectedHyp)]] <- index
  }
  if (winner$finishedPass()) {
    winner$udPass()
    winner$pass <- winner$pass+1
  }
  expert[[wstr]] <- winner
}

for(i in seq_along(expert)){
  #print(paste(expert[[i]]$name,expert[[i]]$rejectedHyp, expert[[i]]$pass,pvals[unlist(expert[[i]]$rejectedHyp)]))
}
```

# Same Bidder

>  Suppose I start the two experts from part 4 with the same constructor object.  How does this set of experts behave compared to the ones in part 4?  How does this help you design bidding strategies?

```{r}
makeMultiExpertSC <- function(..., ncolumns, wealth=.05) {
  sc <- makeRawSource(ncolumns)
  output <- list()
  for (i in seq_along(list(...))) {
    output[[i]] <- makeExpert(
      list(...)[[i]](wealth),
      sc
    )
  }
  output
}

expertConstSC = partial(makeBidderConst, const=.1)
expertGeomSC  = partial(makeBidderGeom,  frac=.1)
expertSC = makeMultiExpert(expertConstSC, expertGeomSC, ncolumns=length(pvals), wealth=omega/2)
names(expertSC) <- c("const","geom")
```

# Single wealth object

> Make  both  experts  from  the  part  d  use  a  single  wealth  object.   This will require you to create a separate wealth object that is passed to both of the bidders, and modify the bidder objects to change the wealth object appropriately.

```{r}
makeBidderGeomSW = function(frac = .5) {
  list( 
    state = function() { list(frac = frac) },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth > .0001, wealth*frac, wealth) }
    # ifelse statement ensures termination by eventually bidding remaining wealth
  )
}

# this bidder always bids a constant amount given by const
makeBidderConstSW = function(const=.01) {
  list( 
    state = function() { list(const = const) },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth >= const, const, wealth) }  
    # can't bid more than current wealth
  )
}

makeExpertSW <- function (bidder, constructor) {
  list(
    name         = "Geom",
    bidder       = bidder,
    constructor  = constructor,
    state        = function() { list(position = constructor$state()$position) },
    bid          = function() { bidder$bid() },
    feature      = function() { constructor$generateFeature() },
    finishedPass = function() { constructor$state()$position == 0 },
    finished     = function() { constructor$state()$nactive == 0 },
    passTest     = function(a) {
      bidder$bidAccepted(a)
      constructor$dropLastFeature() 
    },
    pay          = function(payment) {
      bidder$bidRejected(payment)
    },
    udPass       = function() { constructor$udPass() }
  )
}

makeMultiExpertSW <- function(..., ncolumns) {
  output <- list()
  for (i in seq_along(list(...))) {
    output[[i]] <- makeExpert(
      list(...)[[i]],
      makeRawSource(ncolumns)
    )
  }
  output
}

wealth = omega/2
expertConstSW = makeBidderConstSW(const=.01)
expertGeomSW  = makeBidderGeomSW(frac=.1)

expertSW = makeMultiExpertSW(expertConstSW, expertGeomSW, ncolumns=length(pvals))
names(expertSW) <- c("const","geom")
expertSW$const$name = "Const"

for(i in seq_along(expertSW)){
  expertSW[[i]]$rejectedHyp <- list()
  expertSW[[i]]$pass <- 1
}

while (!reduce(map(expert, function(x) x$finished()), function(x,y) x || y) && wealth > 0) {
  bid = list(const = expertSW$const$bidder$bid(), geom = expertSW$geom$bidder$bid())

  ifelse(bid$const > bid$geom, wstr <- "const", wstr <- "geom")

  winner <- expertSW[[wstr]]
  index = winner$feature()
  maxBid <- max(unlist(bid))

  #print(paste("winner:",wstr ,"index:", index, "wealth:", wealth, "bid:", maxBid, "p:", pvals[min(unlist(index))]))

  winner$pay(maxBid)

  if (pvals[index] < maxBid) {
    winner$passTest(omega)
    winner$rejectedHyp[[1+length(winner$rejectedHyp)]] <- index
  }
  if (winner$finishedPass()) {
    winner$udPass()
    winner$pass <- winner$pass+1
  }
  expertSW[[wstr]] <- winner
}

for(i in seq_along(expertSW)){
  print(paste(expertSW[[i]]$name,expertSW[[i]]$rejectedHyp, expertSW[[i]]$pass,pvals[unlist(expertSW[[i]]$rejectedHyp)]))
}
```
