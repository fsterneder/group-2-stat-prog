---
title: "Project PolyR"
subtitle: "Programming in Statistics - Project"
author: "Vilsmeier Johannes, Sterneder Florian, Schaub Andrea"
date: '`r Sys.Date()`'
output:
  html_document:
    code_folding: show
    css: ../rstyle.css
    theme: cosmo
    highlight: tango
    number_sections: true
    toc: true
    toc_float: yes
    fig_width: 7
    fig_height: 4.5
---

```{r setup, include=FALSE}
library(knitr)
library(tidyverse)
opts_chunk$set(echo = TRUE,
               collapse = FALSE,
               comment = "",
               strip.white = TRUE,
               warning = FALSE,
               messages = FALSE,
               out.width = "70%",
               fig.align = "center")
theme_set(theme_light())
```

# Explanations and drawings {.tabset .tabset-fade .tabset-pills}

> Explain what every function does.  Importantly,  you need to include the environment in which the function is bound and the other variables in this environment.  Alternatively,  you  could  draw  a  picture  of  all  of  the  environments  which  enclose  functions which are bound in the expert list.  Both capture the same information (though the picture is more succinct)

## makeBidderGeom

This function constructs a list containing four functions. One of the functions (state) stores a list with the current state. We have a bidAccepted function which increments the wealth value in the state, the bidRejected which decreases the wealth value and the bid function which implements the geometric behavior of the bid.

```{r eval=F}
makeBidderGeom = function(wealth=.05, frac = .5) {
  list( 
    state = function() { 
      list(
        wealth = wealth,
        frac   = frac
      ) 
    },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth > .0001, wealth*frac, wealth) }
  )
}
```

## makeBidderConst

See makeBidderGeom, almost the same besides the bid function which has a different (constant) bidding behavior and the state.

```{r eval=F}
makeBidderConst = function(wealth=.05, const=.01) {
  list( 
    state = function() { 
      list(
        wealth  = wealth,
        const   = const
      ) 
    },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth >= const, const, wealth) }  
  )
}
```

## makeRawSource

This constructor handles the position of the hypotheses and coordinates where the test is conducted.

```{r eval=F}
makeRawSource <- function(ncolumns) {
  activeColumns  = 0:ncolumns
  position       = ncolumns
  prevPosition   = NA
  nactive        = ncolumns
  
  list(
    name = "Marginal",
    state = function() { 
      list(
        position     = position, 
        prevPosition = prevPosition,
        active       = activeColumns,
        nactive      = sum(!is.na(activeColumns[-1]))
      )
    },
    generateFeature = function() { 
      prevPosition  <<- position
      position      <<- max(activeColumns[activeColumns < position], na.rm=T)
      return(prevPosition) 
    },
    dropLastFeature = function() { activeColumns[prevPosition+1] <<- NA },
    udPass = function() {
      position <<- max(activeColumns, na.rm=T)
      prevPosition <<- NA
    }
  )
}
```

## makeExpert

Takes a bidder and a constructor as input and outputs a list which is used to additionally handle the bidding and other important functions for the hypothesis testing.

```{r eval=F}
makeExpert <- function (bidder, constructor) {
  list(
    name         = "Geom",
    bidder       = bidder,
    constructor  = constructor,
    state        = function() { 
      list(
        wealth   = bidder$state()$wealth,
        position = constructor$state()$position
      )
    },
    bid          = function() { bidder$bid() },
    feature      = function() { constructor$generateFeature() },
    finishedPass = function() { constructor$state()$position == 0 },
    finished     = function() { constructor$state()$nactive == 0 },
    passTest     = function(a) {
      bidder$bidAccepted(a)
      constructor$dropLastFeature() 
    },
    pay          = function(payment) {
      bidder$bidRejected(payment)
    },
    udPass       = function() { constructor$udPass() }
  )
}
```

## makeExpertGeom

Takes `ncolumns` as mandatory input and outputs a new expert.

```{r eval=F}
makeExpertGeom <- function(ncolumns, wealth=.05, frac=.5) {
  makeExpert(
    makeBidderGeom(wealth, frac),
    makeRawSource(ncolumns)
  )
}
```

## environmentDrawing

```{r}
include_graphics("envir.png")
```


# Comment the code

> Comment the code thoroughly. After part 1, you should understand how the code works.  Now comment it to help explain it to others.  Essentially every line should be commented. Remember, you aren’t explaining what the code does,  eg,  for line 42,  “ifelse checks the condition, bids wealth*frac if it holds, otherwise wealth.” Instead, explain why things are done as they are, eg, “ifelse statement ensures termination by eventually bidding remaining wealth”. Note that some things are worth explaining a bit of the how. For example, line 95, “+1 accounts for the zero at the beginning of the activeColumns vector”.

```{r results="hide"}
# Creates a bidder with a geometric bidding strategy, therefore a fractional input can be specified. Also the wealth of the bidder is stored here..
makeBidderGeom = function(wealth=.05, frac = .5) {
  # Function outputs a list
  list( 
    # Stores the wealth and frac in a function (see question 3)
    state = function() { 
      # state outputs a list
      list(
        # outputs the (updated) wealth value of the makeBidder env
        wealth = wealth,
        # outputs the (updated) frac value of the makeBidder env
        frac   = frac
      ) 
    },
    # When a bid was accepted it takes the value of the bid and increments wealth by this value
    bidAccepted = function(a) { wealth <<- wealth + a },
    # Opposite of the function above (decreases the wealth)
    bidRejected = function(d) { wealth <<- wealth - d },
    # Consitutes the bidding strategy of the bidder, ensures eventual termination of the hypothesis test
    bid = function()  { ifelse(wealth > .0001, wealth*frac, wealth) }
  )
}

# Creates a bidder with a constant bidding strategy
makeBidderConst = function(wealth=.05, const=.01) {
  # Function outputs a list
  list( 
    # Stores the wealth and frac in a function (see question 3)
    state = function() { 
      # state outputs a list
      list(
        # outputs the (updated) wealth value of the makeBidder env
        wealth  = wealth,
        # outputs the (updated) frac value of the makeBidder env
        const   = const
      ) 
    },
    # When a bid was accepted it takes the value of the bid and increments wealth (value of makeBidder env) by this value
    bidAccepted = function(a) { wealth <<- wealth + a },
    # Opposite of the function above (decreases the wealth)
    bidRejected = function(d) { wealth <<- wealth - d },
    # Consitutes the bidding strategy of the bidder, ensures eventual termination of the hypothesis test
    bid = function()  { ifelse(wealth >= const, const, wealth) }  
  )
}

# Constructor which takes ncolumns (length of all possible tests) as input
makeRawSource <- function(ncolumns) {
  # vector of positions we could test and a safety zero position
  activeColumns  = 0:ncolumns
  # current position of the test
  position       = ncolumns
  # previous position of the test
  prevPosition   = NA
  # number of remaining tests
  nactive        = ncolumns
  
  # function outputs a list
  list(
    # name
    name = "Marginal",
    # Stores various position parameters (see question 3)
    state = function() {
      # Function outputs a list
      list(
        # Current position of the test
        position     = position, 
        # Previous position of the test
        prevPosition = prevPosition,
        # Vector of positions we could test and a safety zero position
        active       = activeColumns,
        # Number of remaining tests
        nactive      = sum(!is.na(activeColumns[-1]))
      )
    },
    # Ouputs currents position and updates the position
    generateFeature = function() {
      # Updates previous with output prevPosition
      prevPosition  <<- position
      # moves position from current down to the next position (non NA) 
      position      <<- max(activeColumns[activeColumns < position], na.rm=T)
      # outputs current Position
      return(prevPosition) 
    },
    # Function to keep track of the non-rejected values (called when hypothesis is rejected)
    dropLastFeature = function() { 
      # Decrement the activeColumns
      activeColumns[prevPosition+1] <<- NA 
      },
    # Resets the position values after a passed test
    udPass = function() {
      # 
      position <<- max(activeColumns, na.rm=T)
      # Resets prevPosition
      prevPosition <<- NA
    }
  )
}

makeExpert <- function (bidder, constructor) {
#this function takes two variables, a bidder and a constructor. They have to be given. 
#it creates a list, containing the name ("Geom"), the bidder, constructor and 8 functions. 
  list(
    #creating a name variable
    name         = "Geom",
    #bidder is the given bidder (in our case: makeBidderGeom or makeBidderConst)
    bidder       = bidder,
    #constructor is the given constructor (in our case: makeRawSource)
    constructor  = constructor,
    
    #Function 1:
    state        = function() { 
      list(
        #takes the wealth from the bidder
        wealth   = bidder$state()$wealth,
        #takes the position from the constructor
        position = constructor$state()$position
      )
    },
    #Function 2:
    #calls the bid function from (in our case) makeBidder(Geom/Const)
    # --> what is changed?
    bid          = function() { bidder$bid() },
    #Function 3:
    #calls the generateFeature function from (in our case) makeRawSource
    # --> what is changed?
    feature      = function() { constructor$generateFeature() },
    #Function 4:
    #checks the position in state of makeRawSource, T if 0, else --> F
    finishedPass = function() { constructor$state()$position == 0 },
    #Function 5:
    #checks the nactive in state of makeRawSource, T if 0, else --> F
    finished     = function() { constructor$state()$nactive == 0 },
    #Function 6:
    #takes an argument a
    passTest     = function(a) {
      #calls the bidAccepted function to increase the wealth
      bidder$bidAccepted(a)
      #calls the dropLastFeature 
      constructor$dropLastFeature() 
    },
    #Function 7:
    #takes argument payment, makeBidder-bidRejected function with payment
    #wealth is decreased by payment
    pay          = function(payment) {bidder$bidRejected(payment) },
    #Function 8:
    #changes position and prevPosition
    udPass       = function() { constructor$udPass() }
  )
}

makeExpertGeom <- function(ncolumns, wealth=.05, frac=.5) {
#this function takes the number of columns, and optional the wealth and frac. 
#it calls the makeExpert function above, with 
  makeExpert(
  #bidder being the bidder made by the makeBidderGeom function. 
  #The input values for wealth and frac are passed
    makeBidderGeom(wealth, frac),
  #constructor is made by the makeRawSource function. 
  #The input value of ncolumns is passed on. 
    makeRawSource(ncolumns)
  )
}

#setting example data
seed = 421232
set.seed(seed) 
nNull = 20; nNonNull = 20
nulls = runif(nNull)
nonNulls = runif(nNonNull, 0, .05)
pvals = sample(c(nulls, nonNulls)) 

omega = .1
#making an expert, with ncolumns = length(pvals), wealth and frac
expert = makeExpertGeom(length(pvals), wealth=omega, frac=.1)
#making an empty list for the rejectedHyp
rejectedHyp = list()
#setting pass to 1
pass = 1

#run as long as ... 
while (!expert$finished() && expert$state()$wealth > 0) {
  index = expert$feature()
  bid = expert$bidder$bid()
  expert$pay(bid)
  if (pvals[index] < bid) {
    expert$passTest(omega)
    rejectedHyp[[1+length(rejectedHyp)]] = index
  }
  if(expert$finishedPass()) {
    expert$udPass()
    pass = pass+1
  }
}
rejectedHyp; pass
pvals[unlist(rejectedHyp)]
```

# Why a list?

> The state function returns the values of the private variables.  Why is this a function that returns a list and not just a list of the values of the private variables?

If it would be a list the values wouldn't update and would only return the values at the initialization of the parent function. Let's take our bidder function and see how that works practice.

```{r}
makeBidderGeomNoFun = function(wealth=.05, frac = .5) {
  list( 
    state = list(
      wealth = wealth,
      frac   = frac
    ), 
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth > .0001, wealth*frac, wealth) }
  )
}
```
Again, the only difference to our old bidder function is that the state is now a list instead of a function. 

```{r}
setn = 5
testA <- makeBidderGeom()
testB <- makeBidderGeomNoFun()

state <- 
  function() {
    list(
      hasFunction = testA$state()$wealth,
      hasList = testB$state$wealth
    )
  }

state()
```
As we can see we have the same starting values. Now let's take a loop which calls the `bidAccept` function and see what happens to the `state`.

```{r}
while(setn >= 0){
  testA$bidAccepted(100) 
  testB$bidAccepted(100) 
  setn = setn-1
}

state()
```

We find that bidderFunction with a list as a state doesn't update and therefore would be unusable in a program.

# Multiple experts {.tabset .tabset-fade .tabset-pills}

> Generalize the code to use multiple experts (store the experts in a list).  While the code should be general, test it using two experts; one expert should use a geometric bidder and the other should use the constant bidder. Start each expert with wealth = omega/2.  The expert with the maximum bid “wins”, and gets to perform its test.  Note that each expert has private bidder and constructor objects (why?).  Only use one makeExpert function (you should pass it an argument for which bidder function to use).

## Code

```{r}
makeMultiExpert <- function(..., ncolumns, wealth=.05) {
  output <- list()
  for (i in seq_along(list(...))) {
    output[[i]] <- makeExpert(
      list(...)[[i]](wealth),
      makeRawSource(ncolumns)
    )
  }
  output
}
```

To keep the code as simple and as general as possible we opted to use partial function application in regard to the bidder options problem. The other option would be to check which function was supplied and then apply the right option but this would require hardcoding every single bidder and bidder option and wouldn't be general in our opinion.

There are many functional packages that provide partial function application but we went with purrr since we used the tidyverse in our class.

## Example

```{r}
seed = 421232
set.seed(seed) 
nNull = 20; nNonNull = 20
nulls = runif(nNull)
nonNulls = runif(nNonNull, 0, .05)
pvals = sample(c(nulls, nonNulls)) 
omega = .1

expertConst = partial(makeBidderConst, const=.1)
expertGeom  = partial(makeBidderGeom,  frac=.1)
expert = makeMultiExpert(expertConst, expertGeom, ncolumns=length(pvals), wealth=omega/2)
names(expert) <- c("const","geom")
expert$const$name = "Const"

for(i in seq_along(expert)){
  expert[[i]]$rejectedHyp <- list()
  expert[[i]]$pass <- 1
}

while (!reduce(map(expert, function(x) x$finished()), function(x,y) x || y) && reduce(map(expert, function(x) x$state()$wealth > 0), function(x,y) x || y)) {
  bid = list(const = expert$const$bidder$bid(), geom = expert$geom$bidder$bid())

  ifelse(bid$const > bid$geom, wstr <- "const", wstr <- "geom")

  winner <- expert[[wstr]]
  index = winner$feature()
  maxBid <- max(unlist(bid))

  #print(paste("index: ", index, "wealth const: ", expert$const$state()$wealth, "wealth geom: ", expert$geom$state()$wealth, "bid: ", maxBid, "p: ", pvals[min(unlist(index))]))

  winner$pay(maxBid)

  if (pvals[index] < maxBid) {
    winner$passTest(omega)
    winner$rejectedHyp[[1+length(winner$rejectedHyp)]] <- index
  }
  if (winner$finishedPass()) {
    winner$udPass()
    winner$pass <- winner$pass+1
  }
  expert[[wstr]] <- winner
}

for(i in seq_along(expert)){
  print(paste(expert[[i]]$name,expert[[i]]$rejectedHyp, expert[[i]]$pass,pvals[unlist(expert[[i]]$rejectedHyp)]))
}
```

# Same Bidder

>  Suppose I start the two experts from part 4 with the same constructor object.  How does this set of experts behave compared to the ones in part 4?  How does this help you design bidding strategies?

```{r}
makeMultiExpertSC <- function(..., ncolumns, wealth=.05) {
  sc <- makeRawSource(ncolumns)
  output <- list()
  for (i in seq_along(list(...))) {
    output[[i]] <- makeExpert(
      list(...)[[i]](wealth),
      sc
    )
  }
  output
}

expertConstSC = partial(makeBidderConst, const=.1)
expertGeomSC  = partial(makeBidderGeom,  frac=.1)
expertSC = makeMultiExpert(expertConstSC, expertGeomSC, ncolumns=length(pvals), wealth=omega/2)
names(expertSC) <- c("const","geom")
```

# Single wealth object

> Make  both  experts  from  the  part  d  use  a  single  wealth  object.   This will require you to create a separate wealth object that is passed to both of the bidders, and modify the bidder objects to change the wealth object appropriately.

```{r}
makeBidderGeomSW = function(frac = .5) {
  list( 
    state = function() { list(frac = frac) },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth > .0001, wealth*frac, wealth) }
    # ifelse statement ensures termination by eventually bidding remaining wealth
  )
}

# this bidder always bids a constant amount given by const
makeBidderConstSW = function(const=.01) {
  list( 
    state = function() { list(const = const) },
    bidAccepted = function(a) { wealth <<- wealth + a },
    bidRejected = function(d) { wealth <<- wealth - d },
    bid = function()  { ifelse(wealth >= const, const, wealth) }  
    # can't bid more than current wealth
  )
}

makeExpertSW <- function (bidder, constructor) {
  list(
    name         = "Geom",
    bidder       = bidder,
    constructor  = constructor,
    state        = function() { list(position = constructor$state()$position) },
    bid          = function() { bidder$bid() },
    feature      = function() { constructor$generateFeature() },
    finishedPass = function() { constructor$state()$position == 0 },
    finished     = function() { constructor$state()$nactive == 0 },
    passTest     = function(a) {
      bidder$bidAccepted(a)
      constructor$dropLastFeature() 
    },
    pay          = function(payment) {
      bidder$bidRejected(payment)
    },
    udPass       = function() { constructor$udPass() }
  )
}

makeMultiExpertSW <- function(..., ncolumns) {
  output <- list()
  for (i in seq_along(list(...))) {
    output[[i]] <- makeExpert(
      list(...)[[i]],
      makeRawSource(ncolumns)
    )
  }
  output
}

wealth = omega/2
expertConstSW = makeBidderConstSW(const=.01)
expertGeomSW  = makeBidderGeomSW(frac=.1)

expertSW = makeMultiExpertSW(expertConstSW, expertGeomSW, ncolumns=length(pvals))
names(expertSW) <- c("const","geom")
expertSW$const$name = "Const"

for(i in seq_along(expertSW)){
  expertSW[[i]]$rejectedHyp <- list()
  expertSW[[i]]$pass <- 1
}

while (!reduce(map(expert, function(x) x$finished()), function(x,y) x || y) && wealth > 0) {
  bid = list(const = expertSW$const$bidder$bid(), geom = expertSW$geom$bidder$bid())

  ifelse(bid$const > bid$geom, wstr <- "const", wstr <- "geom")

  winner <- expertSW[[wstr]]
  index = winner$feature()
  maxBid <- max(unlist(bid))

  #print(paste("winner:",wstr ,"index:", index, "wealth:", wealth, "bid:", maxBid, "p:", pvals[min(unlist(index))]))

  winner$pay(maxBid)

  if (pvals[index] < maxBid) {
    winner$passTest(omega)
    winner$rejectedHyp[[1+length(winner$rejectedHyp)]] <- index
  }
  if (winner$finishedPass()) {
    winner$udPass()
    winner$pass <- winner$pass+1
  }
  expertSW[[wstr]] <- winner
}

for(i in seq_along(expertSW)){
  print(paste(expertSW[[i]]$name,expertSW[[i]]$rejectedHyp, expertSW[[i]]$pass,pvals[unlist(expertSW[[i]]$rejectedHyp)]))
}
```
